# 2. Багатошарова архітектура та розділення відповідальності

Date: 2025-12-18
Status: Accepted

## Context
В проекті впроваджується архітектура "Модульний Моноліт". Щоб уникнути змішування коду ("Spaghetti code") та забезпечити тестування бізнес-логіки окремо від бази даних та HTTP-сервера, необхідно чітко визначити правила взаємодії між компонентами системи.

## Decision
Ми приймаємо сувору **Багатошарову Архітектуру (Layered Architecture)**. Весь код функціоналу поділяється на три основні шари з чіткими межами відповідальності.

### 1. Структура шарів (Responsibilities)

#### A. Presentation Layer (`src/api/`)
* **Що зберігається:** Контролери (Controllers), Маршрути (Routes), DTO (схеми запитів/відповідей).
* **Відповідальність:** * Прийом HTTP-запитів.
    * Парсинг вхідних даних.
    * Виклик методів Сервісу.
    * Відправка HTTP-відповідей (статус коди, JSON).
* **Заборонено:** Виконувати бізнес-логіку, звертатися до бази даних напряму.

#### B. Application/Service Layer (`src/application/services/`)
* **Що зберігається:** Сервіси (Services), Use-Cases.
* **Відповідальність:** * Оркестрація бізнес-операцій.
    * Перетворення DTO у Доменні Сутності.
    * Виклик Репозиторіїв для збереження даних.
    * Валідація бізнес-сценаріїв (наприклад, перевірка, чи існує користувач перед створенням витрати).
* **Заборонено:** Знати про HTTP (req, res), залежати від конкретного фреймворку (Express).

#### C. Domain Layer (`src/domain/`)
* **Що зберігається:** Сутності (Entities), Об'єкти-значення (Value Objects), Доменні події.
* **Відповідальність:** * Інкапсуляція бізнес-правил та інваріантів (наприклад: "сума не може бути нульовою", "опис мінімум 3 символи").
    * Чиста логіка, незалежна від зовнішнього світу.
* **Заборонено:** Будь-які зовнішні залежності (БД, API, файлова система).

#### D. Infrastructure Layer (`src/infrastructure/`)
* **Що зберігається:** Репозиторії (Repositories), конфігурація БД, зовнішні клієнти.
* **Відповідальність:** Реалізація технічного доступу до даних (SQL запити).

---

### 2. Напрямок залежностей (Dependencies)
Потік керування та залежностей суворо **"Зверху вниз"**:

`API (Controller)` -> `Application (Service)` -> `Domain (Entity)` & `Infrastructure (Repository)`

1.  **API** знає про **Service**.
2.  **Service** знає про **Repository** та **Domain**.
3.  **Domain** ні про кого не знає (Zero Dependencies).

### 3. Заборонені зв'язки (Restrictions)
1.  ❌ **API -> Database:** Контролери ніколи не викликають методи БД і не пишуть SQL.
2.  ❌ **API -> Domain (Logic):** Контролери не створюють бізнес-логіку, вони лише передають дані в Сервіс.
3.  ❌ **Domain -> Infrastructure:** Доменні класи не повинні знати, як вони зберігаються.
4.  ❌ **Cross-Layer Skipping:** Не можна з API викликати Репозиторій, оминаючи Сервіс (навіть для простих CRUD операцій, щоб зберегти єдину точку входу).

## Consequences
* **Позитивні:** Висока тестопридатність (можна тестувати домен без бази), легкість рефакторингу, чітке розуміння де шукати код.
* **Негативні:** Поява "Boilerplate" коду (сервіси-проксі), збільшення кількості файлів.